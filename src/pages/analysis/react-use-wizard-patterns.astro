---
import Header from "../../components/Header.astro"
import Layout from "../../layouts/Layout.astro"
---

<Layout title="What I Learned from react-use-wizard's Source Code - learnfromcode">
	<Header />
	
	<main class="max-w-4xl mx-auto px-6 py-12 bg-white dark:bg-gray-900 transition-colors">
		<!-- Header Section -->
		<div class="mb-6">
			<a href="/analysis" class="text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 text-sm transition-colors inline-flex items-center">
				<svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
					<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m0 0l8 8a1 1 0 010 1.414l-8 8z" />
				</svg>
				Back to Analysis
			</a>
		</div>

		<!-- Article Header -->
		<article class="prose prose-lg max-w-none">
			<div class="mb-8">
				<div class="flex flex-wrap items-center gap-2 mb-4">
					<span class="bg-blue-600 text-white px-3 py-1 text-sm rounded font-medium">
						Featured Analysis
					</span>
					<span class="bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 px-3 py-1 text-sm rounded">
						react-use-wizard
					</span>
					<span class="bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 px-3 py-1 text-sm rounded">
						Intermediate
					</span>
					<span class="text-gray-600 dark:text-gray-400 text-sm">
						8 min read
					</span>
				</div>
				
				<h1 class="text-4xl md:text-5xl font-bold text-gray-900 dark:text-white mb-6">
					What I Learned from react-use-wizard's Source Code
				</h1>
				
				<!-- Hook -->
				<div class="bg-blue-50 dark:bg-blue-900/20 border-l-4 border-blue-500 p-6 mb-8">
					<p class="text-lg text-gray-900 dark:text-white font-medium leading-relaxed">
						<strong>How do you build a wizard component that works with any UI library?</strong><br>
						I analyzed react-use-wizard's source code and found <strong>5 clever patterns</strong> that every React developer should know.
					</p>
				</div>
			</div>

			<!-- Introduction -->
			<section class="mb-12">
				<p class="text-gray-700 dark:text-gray-300 text-lg leading-relaxed mb-6">
					When I was building a multi-step form for a client project, I stumbled upon <strong>react-use-wizard</strong>. 
					Unlike other wizard libraries that force you into their UI decisions, this one felt different. It was flexible, 
					lightweight, and surprisingly powerful.
				</p>
				
				<p class="text-gray-700 dark:text-gray-300 text-lg leading-relaxed mb-6">
					The library solves a common problem: <strong>managing multi-step flows</strong> without being opinionated about your UI. 
					Whether you're building a form wizard, onboarding flow, or checkout process, it handles the state management 
					while letting you control the presentation completely.
				</p>
				
				<p class="text-gray-700 dark:text-gray-300 text-lg leading-relaxed mb-6">
					Today, I'll break down the 5 most ingenious patterns I found in its source code, explain how they work, 
					and show you how to apply these techniques in your own React projects.
				</p>
			</section>

			<!-- Pattern 1 -->
			<section class="mb-12">
				<h2 class="text-3xl font-bold text-gray-900 dark:text-white mb-6">
					üì¶ Pattern 1: Compound Components Done Right
				</h2>
				
				<p class="text-gray-700 dark:text-gray-300 text-lg leading-relaxed mb-6">
					Most wizard libraries force you to pass an array of steps and render them with their predefined components:
				</p>
				
				<!-- Code Block -->
				<div class="bg-gray-900 rounded-lg p-6 mb-6">
					<div class="flex items-center justify-between mb-4">
						<span class="text-gray-400 text-sm">‚ùå Most wizards force you into their UI</span>
					</div>
					<pre class="text-gray-100 text-sm overflow-x-auto"><code class="language-jsx">{`<Wizard steps={[
  { title: "Step 1", component: Step1Component },
  { title: "Step 2", component: Step2Component },
]} />`}</code></pre>
				</div>
				
				<p class="text-gray-700 dark:text-gray-300 text-lg leading-relaxed mb-6">
					But react-use-wizard takes a completely different approach using compound components:
				</p>
				
				<!-- Code Block -->
				<div class="bg-gray-900 rounded-lg p-6 mb-6">
					<div class="flex items-center justify-between mb-4">
						<span class="text-green-400 text-sm">‚úÖ react-use-wizard lets you compose naturally</span>
					</div>
					<pre class="text-gray-100 text-sm overflow-x-auto"><code class="language-jsx">{`<Wizard>
  <Step1 />
  <Step2 />
  <Step3 />
</Wizard>`}</code></pre>
				</div>
				
				<p class="text-gray-700 dark:text-gray-300 text-lg leading-relaxed mb-6">
					<strong>How it works technically:</strong> The library uses React.Children.toArray() to discover steps at runtime, 
					then provides navigation state through context. This pattern gives you complete control over each step's JSX 
					while the library handles the orchestration.
				</p>
				
				<p class="text-gray-700 dark:text-gray-300 text-lg leading-relaxed mb-6">
					<strong>Why it's better:</strong> You can use any components, apply conditional rendering, and compose steps 
					with your existing design system without fighting the library's opinions.
				</p>
				
				<p class="text-gray-700 dark:text-gray-300 text-lg leading-relaxed mb-6">
					<strong>When to use it:</strong> Perfect for complex forms, onboarding flows, or any multi-step process 
					where you need full control over the UI but want help managing the state.
				</p>
			</section>

			<!-- Pattern 2 -->
			<section class="mb-12">
				<h2 class="text-3xl font-bold text-gray-900 dark:text-white mb-6">
					‚ö° Pattern 2: Smart Handler Attachment
				</h2>
				
				<p class="text-gray-700 dark:text-gray-300 text-lg leading-relaxed mb-6">
					One of the most clever patterns is how it handles step validation and async operations:
				</p>
				
				<!-- Code Block -->
				<div class="bg-gray-900 rounded-lg p-6 mb-6">
					<div class="flex items-center justify-between mb-4">
						<span class="text-green-400 text-sm">Smart async handler with automatic loading state</span>
					</div>
					<pre class="text-gray-100 text-sm overflow-x-auto"><code class="language-jsx">{`const Step1 = () => {
  const { handleStep } = useWizard();
  
  handleStep(async () => {
    await saveUserData(); // Auto-handles loading state!
    return true; // Proceed to next step
  });
  
  return <form>...</form>;
}`}</code></pre>
				</div>
				
				<p class="text-gray-700 dark:text-gray-300 text-lg leading-relaxed mb-6">
					<strong>The magic:</strong> The handleStep function automatically manages loading states, error handling, 
					and conditional navigation based on your async function's return value. If it returns false or throws, 
					the wizard stays on the current step.
				</p>
				
				<p class="text-gray-700 dark:text-gray-300 text-lg leading-relaxed mb-6">
					<strong>Why it's brilliant:</strong> You write normal async code, and the library handles all the 
					edge cases around loading, errors, and navigation flow automatically.
				</p>
			</section>

			<!-- Pattern 3 -->
			<section class="mb-12">
				<h2 class="text-3xl font-bold text-gray-900 dark:text-white mb-6">
					üéØ Pattern 3: Flexible Step Discovery
				</h2>
				
				<p class="text-gray-700 dark:text-gray-300 text-lg leading-relaxed mb-6">
					The library doesn't require you to register steps ahead of time. Instead, it dynamically discovers 
					them from your JSX structure, making conditional steps incredibly easy:
				</p>
				
				<!-- Code Block -->
				<div class="bg-gray-900 rounded-lg p-6 mb-6">
					<pre class="text-gray-100 text-sm overflow-x-auto"><code class="language-jsx">{`<Wizard>
  <UserInfoStep />
  {isPremiumUser && <BillingStep />}
  <ConfirmationStep />
</Wizard>`}</code></pre>
				</div>
				
				<p class="text-gray-700 dark:text-gray-300 text-lg leading-relaxed mb-6">
					The wizard automatically adjusts its internal step count and navigation based on which components 
					are actually rendered. No configuration needed.
				</p>
			</section>

			<!-- Code Deep Dive -->
			<section class="mb-12">
				<h2 class="text-3xl font-bold text-gray-900 dark:text-white mb-6">
					üîç Code Deep Dive: The Heart of the Magic
				</h2>
				
				<p class="text-gray-700 dark:text-gray-300 text-lg leading-relaxed mb-6">
					Here's the core logic that makes the compound component pattern work:
				</p>
				
				<!-- Code Block -->
				<div class="bg-gray-900 rounded-lg p-6 mb-6">
					<div class="flex items-center justify-between mb-4">
						<span class="text-blue-400 text-sm">From react-use-wizard source</span>
					</div>
					<pre class="text-gray-100 text-sm overflow-x-auto"><code class="language-javascript">{`// This is the genius: dynamic step discovery
const stepCount = useMemo(() => {
  return React.Children.toArray(children).length;
}, [children]);

// Active step rendering
const activeStepContent = useMemo(() => {
  const childrenArray = React.Children.toArray(children);
  return childrenArray[activeStep] || null;
}, [children, activeStep]);`}</code></pre>
				</div>
				
				<p class="text-gray-700 dark:text-gray-300 text-lg leading-relaxed mb-6">
					<strong>Line by line breakdown:</strong>
				</p>
				
				<ul class="text-gray-700 dark:text-gray-300 text-lg leading-relaxed mb-6 space-y-2">
					<li><strong>Line 2-4:</strong> React.Children.toArray() converts the JSX children to an array, automatically handling conditional rendering</li>
					<li><strong>Line 7-10:</strong> Only the active step component is rendered, keeping memory usage low and avoiding unnecessary renders</li>
					<li><strong>Dependencies:</strong> Both useMemo hooks depend on children, so they re-calculate when your JSX structure changes</li>
				</ul>
				
				<p class="text-gray-700 dark:text-gray-300 text-lg leading-relaxed mb-6">
					<strong>This is why it works:</strong> By treating children as dynamic data, the component can adapt 
					to any JSX structure while maintaining predictable behavior.
				</p>
			</section>

			<!-- Lessons -->
			<section class="mb-12">
				<h2 class="text-3xl font-bold text-gray-900 dark:text-white mb-6">
					üí° Lessons for Your Own Code
				</h2>
				
				<div class="space-y-6">
					<div class="bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800/50 rounded-lg p-6">
						<h3 class="text-xl font-semibold text-green-800 dark:text-green-200 mb-3">
							1. Embrace Compound Components for Complex UIs
						</h3>
						<p class="text-green-700 dark:text-green-300">
							Instead of passing configuration objects, let users compose your component with JSX. 
							It's more flexible and feels more natural in React.
						</p>
					</div>
					
					<div class="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800/50 rounded-lg p-6">
						<h3 class="text-xl font-semibold text-blue-800 dark:text-blue-200 mb-3">
							2. Use React.Children for Dynamic Discovery
						</h3>
						<p class="text-blue-700 dark:text-blue-300">
							React.Children.toArray() is perfect for building components that need to adapt to 
							different numbers or types of children at runtime.
						</p>
					</div>
					
					<div class="bg-purple-50 dark:bg-purple-900/20 border border-purple-200 dark:border-purple-800/50 rounded-lg p-6">
						<h3 class="text-xl font-semibold text-purple-800 dark:text-purple-200 mb-3">
							3. Abstract State Management, Not UI
						</h3>
						<p class="text-purple-700 dark:text-purple-300">
							The best libraries handle complex logic (navigation, validation, async operations) 
							while giving developers complete control over presentation.
						</p>
					</div>
				</div>
				
				<div class="mt-8">
					<h3 class="text-xl font-semibold text-gray-900 dark:text-white mb-4">Common Mistakes to Avoid:</h3>
					<ul class="text-gray-700 dark:text-gray-300 text-lg leading-relaxed space-y-2">
						<li>‚Ä¢ <strong>Over-constraining UI:</strong> Don't force users into your design decisions</li>
						<li>‚Ä¢ <strong>Ignoring conditional rendering:</strong> Always test your components with dynamic children</li>
						<li>‚Ä¢ <strong>Complex configuration:</strong> If you need a 50-line config object, consider compound components instead</li>
					</ul>
				</div>
			</section>

			<!-- Call to Action -->
			<section class="border-t border-gray-200 dark:border-gray-700 pt-8">
				<div class="bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-blue-900/20 dark:to-indigo-900/20 rounded-lg p-8 text-center">
					<h2 class="text-2xl font-bold text-gray-900 dark:text-white mb-4">
						Want More Code Analysis?
					</h2>
					<p class="text-gray-700 dark:text-gray-300 mb-6">
						Next week I'm analyzing <strong>Zustand's state management</strong> and the clever tricks 
						they use to keep the API so clean and performant.
					</p>
					<div class="flex flex-col sm:flex-row gap-3 max-w-md mx-auto">
						<input 
							type="email" 
							placeholder="your@email.com" 
							class="flex-1 px-4 py-2 rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500"
						>
						<button class="bg-blue-600 text-white px-6 py-2 rounded-lg font-medium hover:bg-blue-700 transition-colors">
							Get Notified
						</button>
					</div>
					<p class="text-gray-600 dark:text-gray-400 text-sm mt-3">
						Join 1,200+ developers learning from the best code
					</p>
				</div>
				
				<div class="mt-8 flex flex-wrap gap-2">
					<span class="text-gray-600 dark:text-gray-400">Tags:</span>
					<span class="text-blue-600 dark:text-blue-400">#react</span>
					<span class="text-blue-600 dark:text-blue-400">#typescript</span>
					<span class="text-blue-600 dark:text-blue-400">#componentdesign</span>
					<span class="text-blue-600 dark:text-blue-400">#hooks</span>
					<span class="text-blue-600 dark:text-blue-400">#opensource</span>
				</div>
			</section>
		</article>
	</main>
</Layout>

<style>
	.prose {
		color: inherit;
	}
	.prose h1, .prose h2, .prose h3 {
		color: inherit;
	}
	.prose code {
		background-color: rgb(31 41 55);
		color: rgb(229 231 235);
		padding: 0.125rem 0.25rem;
		border-radius: 0.25rem;
		font-size: 0.875em;
	}
	.prose pre {
		background-color: rgb(17 24 39);
		border-radius: 0.5rem;
	}
	.prose pre code {
		background-color: transparent;
		color: rgb(229 231 235);
		padding: 0;
	}
</style>
